/*********************************************************************
 *											   						 *
 *    DESCRIPTION: Text Character Generator and Drawing functions  	 *
 *											  						 *
 *	  CATEGORY:   BIOS Driver										 *
 *											  						 *
 *    AUTHOR: Stephen Tenniswood, Software Engineer 	 			 *
 *			  	  May 7, 2007						 				 *
 *											   						 *
 *    PURPOSE: To draw text charactors on bitmap only LCD			 *
 *			 These routines define cursor coordinates independant 	 *
 *			 of the two controllers and their coordinates			 *
 *			
 *			 For the 128x64 LCD, this resuls in a 20x8 line display	 *
 *  		 The character set is 6x8 bitmap chars. The bitmaps were *
 *  		 obtained from 											 *
 * http://www.piclist.com/techref/datafile/charset/extractor/font6x8pic8.asm.txt
 *																	 *
 *********************************************************************/
#include "pgmspace.h"
#include "pin_definitions.h"
#include "lcd_icons.h"
#include "lcd_driver.h"


// Char set contains 96 chars.  6 bytes wide.
const byte CharSet[96][6] PROGMEM = {
	{ 0x00,0x00,0x00,0x00,0x00,0x00},	//    0
	{ 0x00,0x00,0x06,0x5F,0x06,0x00},	// !  1
	{ 0x00,0x07,0x03,0x00,0x07,0x03},	// "  2
	{ 0x00,0x24,0x7E,0x24,0x7E,0x24},	// #  3
	{ 0x00,0x24,0x2B,0x6A,0x12,0x00},	// $  4
	{ 0x00,0x63,0x13,0x08,0x64,0x63},	// %  5
	{ 0x00,0x36,0x49,0x56,0x20,0x50},	// &  6
	{ 0x00,0x00,0x07,0x03,0x00,0x00},	// '  7
	{ 0x00,0x00,0x3E,0x41,0x00,0x00},	// (  8
	{ 0x00,0x00,0x41,0x3E,0x00,0x00},	// )  9
	{ 0x00,0x08,0x3E,0x1C,0x3E,0x08},	// *  10
	{ 0x00,0x08,0x08,0x3E,0x08,0x08},	// +  11
	{ 0x00,0x00,0xE0,0x60,0x00,0x00},	// ,  12
	{ 0x00,0x08,0x08,0x08,0x08,0x08},	// -  13
	{ 0x00,0x00,0x60,0x60,0x00,0x00},	// .  14
	{ 0x00,0x20,0x10,0x08,0x04,0x02},	// /  15
	{ 0x00,0x3E,0x51,0x49,0x45,0x3E},	// 0  16 (normally .48 ASCII)
	{ 0x00,0x00,0x42,0x7F,0x40,0x00},	// 1   therefore from ASCII value,
	{ 0x00,0x62,0x51,0x49,0x49,0x46},	// 2	subtract 32
	{ 0x00,0x22,0x49,0x49,0x49,0x36},	// 3
	{ 0x00,0x18,0x14,0x12,0x7F,0x10},	// 4
	{ 0x00,0x2F,0x49,0x49,0x49,0x31},	// 5
	{ 0x00,0x3C,0x4A,0x49,0x49,0x30},	// 6
	{ 0x00,0x01,0x71,0x09,0x05,0x03},	// 7
	{ 0x00,0x36,0x49,0x49,0x49,0x36},	// 8
	{ 0x00,0x06,0x49,0x49,0x29,0x1E},	// 9
	{ 0x00,0x00,0x6C,0x6C,0x00,0x00},	// :
	{ 0x00,0x00,0xEC,0x6C,0x00,0x00},	// ;
	{ 0x00,0x08,0x14,0x22,0x41,0x00},	// <
	{ 0x00,0x24,0x24,0x24,0x24,0x24},	// =
	{ 0x00,0x00,0x41,0x22,0x14,0x08},	// >
	{ 0x00,0x02,0x01,0x59,0x09,0x06},	// ?
	{ 0x00,0x3E,0x41,0x5D,0x55,0x1E},	// @
	{ 0x00,0x7E,0x11,0x11,0x11,0x7E},	// A
	{ 0x00,0x7F,0x49,0x49,0x49,0x36},	// B
	{ 0x00,0x3E,0x41,0x41,0x41,0x22},	// C
	{ 0x00,0x7F,0x41,0x41,0x41,0x3E},	// D
	{ 0x00,0x7F,0x49,0x49,0x49,0x41},	// E
	{ 0x00,0x7F,0x09,0x09,0x09,0x01},	// F
	{ 0x00,0x3E,0x41,0x49,0x49,0x7A},	// G
	{ 0x00,0x7F,0x08,0x08,0x08,0x7F},	// H
	{ 0x00,0x00,0x41,0x7F,0x41,0x00},	// I
	{ 0x00,0x30,0x40,0x40,0x40,0x3F},	// J
	{ 0x00,0x7F,0x08,0x14,0x22,0x41},	// K
	{ 0x00,0x7F,0x40,0x40,0x40,0x40},	// L
	{ 0x00,0x7F,0x02,0x04,0x02,0x7F},	// M
	{ 0x00,0x7F,0x02,0x04,0x08,0x7F},	// N
	{ 0x00,0x3E,0x41,0x41,0x41,0x3E},	// O
	{ 0x00,0x7F,0x09,0x09,0x09,0x06},	// P
	{ 0x00,0x3E,0x41,0x51,0x21,0x5E},	// Q
	{ 0x00,0x7F,0x09,0x09,0x19,0x66},	// R
	{ 0x00,0x26,0x49,0x49,0x49,0x32},	// S
	{ 0x00,0x01,0x01,0x7F,0x01,0x01},	// T
	{ 0x00,0x3F,0x40,0x40,0x40,0x3F},	// U
	{ 0x00,0x1F,0x20,0x40,0x20,0x1F},	// V
	{ 0x00,0x3F,0x40,0x3C,0x40,0x3F},	// W
	{ 0x00,0x63,0x14,0x08,0x14,0x63},	// X
	{ 0x00,0x07,0x08,0x70,0x08,0x07},	// Y
	{ 0x00,0x71,0x49,0x45,0x43,0x00},	// Z
	{ 0x00,0x00,0x7F,0x41,0x41,0x00},	// [
	{ 0x00,0x02,0x04,0x08,0x10,0x20},	// backslash

	{ 0x00,0x00,0x41,0x41,0x7F,0x00},	// ]
	{ 0x00,0x04,0x02,0x01,0x02,0x04},	// ^
	{ 0x80,0x80,0x80,0x80,0x80,0x80},	// _
	{ 0x00,0x00,0x03,0x07,0x00,0x00},	// `
	{ 0x00,0x20,0x54,0x54,0x54,0x78},	// a
	{ 0x00,0x7F,0x44,0x44,0x44,0x38},	// b
	{ 0x00,0x38,0x44,0x44,0x44,0x28},	// c
	{ 0x00,0x38,0x44,0x44,0x44,0x7F},	// d
	{ 0x00,0x38,0x54,0x54,0x54,0x08},	// e
	{ 0x00,0x08,0x7E,0x09,0x09,0x00},	// f
	{ 0x00,0x18,0xA4,0xA4,0xA4,0x7C},	// g
	{ 0x00,0x7F,0x04,0x04,0x78,0x00},	// h
	{ 0x00,0x00,0x00,0x7D,0x40,0x00},	// i
	{ 0x00,0x40,0x80,0x84,0x7D,0x00},	// j
	{ 0x00,0x7F,0x10,0x28,0x44,0x00},	// k
	{ 0x00,0x00,0x00,0x7F,0x40,0x00},	// l
	{ 0x00,0x7C,0x04,0x18,0x04,0x78},	// m
	{ 0x00,0x7C,0x04,0x04,0x78,0x00},	// n
	{ 0x00,0x38,0x44,0x44,0x44,0x38},	// o
	{ 0x00,0xFC,0x44,0x44,0x44,0x38},	// p
	{ 0x00,0x38,0x44,0x44,0x44,0xFC},	// q
	{ 0x00,0x44,0x78,0x44,0x04,0x08},	// r
	{ 0x00,0x08,0x54,0x54,0x54,0x20},	// s
	{ 0x00,0x04,0x3E,0x44,0x24,0x00},	// t
	{ 0x00,0x3C,0x40,0x20,0x7C,0x00},	// u
	{ 0x00,0x1C,0x20,0x40,0x20,0x1C},	// v
	{ 0x00,0x3C,0x60,0x30,0x60,0x3C},	// w
	{ 0x00,0x6C,0x10,0x10,0x6C,0x00},	// x
	{ 0x00,0x9C,0xA0,0x60,0x3C,0x00},	// y
	{ 0x00,0x64,0x54,0x54,0x4C,0x00},	// z
	{ 0x00,0x08,0x3E,0x41,0x41,0x00},	// {
	{ 0x00,0x00,0x00,0x77,0x00,0x00},	// |
	{ 0x00,0x00,0x41,0x41,0x3E,0x08},	// }
	{ 0x00,0x02,0x01,0x02,0x01,0x00},	// ~
	{ 0x00,0x3C,0x26,0x23,0x26,0x3C}	// 
};

void EOL_WrapAround_Check_Small()
{
	byte y_address = Get_y_address();
	byte x_address = Get_x_address();
	
	// do EOL carriage return 
	if (y_address > 122) 
	{ 	
		// Move back to start of line:
		Set_y_address( 0 );
		
		// Goto Next Line
		if (x_address >= 5) 
			x_address = 0;
		else
			x_address += 1;
			
		Set_x_address( x_address );
		SendAddresses();
	}	
}

byte CenterText( byte mNumChars, byte mStartCol, byte mEndCol)
{
	word OccupiedX = mNumChars*6;
	word StartX = (mEndCol - mStartCol-OccupiedX)>>1;
	return StartX;	
}

// Draws Character at current cursor position.
// INPUT:  index into the character set
void Draw_Char(int char_index)
{
	const _far char* ptr = 0;

	//EOL_WrapAround_Check_Small();

	ptr = (const char*)CharSet[char_index];
	TransferBufferFixedLength(ptr, 6);	
};  

// Draws Character at current cursor position.
// INPUT:  ASCII char
void Char_Out(char ascii)
{
	byte index = ascii - 32;
	Draw_Char(index);
};

// Draws a String on LCD at current position.
// The string resides in PROGMEM
void Text_Out_Progmem(_far char* string )
{
	int i=0;
	while (string[i] != 0)
	{
		Char_Out( pgm_read_byte(string+i) );
		i++;
	};
};
// Draws a String on LCD at current position.
// The string resides in RAM
void Text_Out(_far char* string )
{
	int i=0;
	while (string[i] != 0)
	{
		Char_Out(string[i++]);
	};
};

// Draws a string and returns to next line.
void Text_Ln_Progmem(_far char* string )
{
	Text_Out_Progmem(string);
	Increment_x_address();
	Set_y_address (0);
	SendAddresses();
}
// Draws a string and returns to next line.
void Text_Ln(_far char* string )
{
	Text_Out(string);
	Increment_x_address();
	Set_y_address (0);
	SendAddresses();
}

// Draws char at specified position.
// Row is the line number [0..7]
// Column is the column [0..20]
void Draw_Char_At(int Row, int Column, int char_index)
{	
	if (Row > 7)   Row=7;
	if (Column>20) Column=20;

	GotoAddress(Row, Column*6+2 );
	TransferBufferFixedLength( (const char*)CharSet[char_index], 6);
};


byte get_ascii_nibble( byte mNib )
{
	if (mNib < 0x0A)
	{
		return (mNib + 0x30);
	}
	else
	{ 
		return ((mNib-0x0A) + 0x41);
	}
}

void lcd_draw_byte( byte mData )
{
	byte ascii_l = get_ascii_nibble( mData & 0x0F );
	byte ascii_h = get_ascii_nibble( (mData & 0xF0)>>4 );
	Char_Out(ascii_h);
	Char_Out(ascii_l);
}

void lcd_draw_word	( word mData )
{
	lcd_draw_byte( ((mData & 0xFF00)>>8) );	
	lcd_draw_byte( mData & 0x00FF );
}

// For test purposes, draws a row of chars on LCD.
void DrawCharSet()
{	
	int index=0;
	GotoAddress (0,0);
	for (index = 0; index < 21; index++)
	   Draw_Char( index  );

	//GotoAddress (1,0);
	for (; index < 42; index++)
	   Draw_Char( index  );

	//GotoAddress (2,0);
	for (; index < 63; index++)
	   Draw_Char( index  );

	//GotoAddress (3,0);
	for (; index < 84; index++)
	   Draw_Char( index  );

	//GotoAddress (4,0);
	for (; index < 96; index++)
	   Draw_Char( index  ); 
}
