/*
 *
 * Arial Bold 14
 *
 * created with FontCreator
 * written by F. Maximilian Thiele
 *
 * http://www.apetech.de/fontCreator
 * me@apetech.de
 *
 * File Name           : arial_bold_14
 * Date                : 29.01.2005
 * Font size in bytes  : 8712
 * Font width          : 10
 * Font height         : 14
 * Font first char     : 32
 * Font last char      : 128
 * Font used chars     : 96
 *
 * The font data are defined as
 *
 * struct _FONT_ {
 *     uint16_t   font_Size_in_Bytes_over_all_included_Size_it_self;
 *     uint8_t    font_Width_in_Pixel_for_fixed_drawing;
 *     uint8_t    font_Height_in_Pixel_for_all_characters;
 *     unit8_t    font_First_Char;
 *     uint8_t    font_Char_Count;
 *
 *     uint8_t    font_Char_Widths[font_Last_Char - font_First_Char +1];
 *                  // for each character the separate width in pixels,
 *                  // characters < 128 have an implicit virtual right empty row
 *
 *     uint8_t    font_data[];
 *                  // bit field of all characters
 */
#include "iom16m1.h"
#include <string.h>
#include <avr/sfr_defs.h>
#include "inttypes.h"
#include "pgmspace.h"
#include "../pin_definitions.h"
#include "../LCD_Driver.h"
#include "../core/leds.h"
#include "bk_system_defs.h"
#include "Arial_bold_14.h"

#define GLCD_OLD_FONTDRAW 1
#define ARIAL_BOLD_14_WIDTH 10
#define ARIAL_BOLD_14_HEIGHT 14

uint8_t			need_scroll = 0; // set when text scroll has been defered

uint8_t Arial_bold_14[]  = {
    0x22, 0x08, // size
    0x0A, // width
    0x0E, // height
    0x20, // first char
    0x60, // char count
    
    // char widths
    0x04, 0x02, 0x05, 0x06, 0x07, 0x08, 0x09, 0x02, 0x03, 0x03, 
    0x05, 0x08, 0x02, 0x04, 0x02, 0x04, 0x07, 0x04, 0x07, 0x07, 
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x02, 0x02, 0x07, 0x07, 
    0x07, 0x08, 0x0E, 0x09, 0x08, 0x08, 0x08, 0x07, 0x07, 0x09, 
    0x08, 0x02, 0x07, 0x08, 0x07, 0x0B, 0x08, 0x09, 0x07, 0x09, 
    0x09, 0x07, 0x08, 0x08, 0x09, 0x0D, 0x07, 0x08, 0x08, 0x04, 
    0x04, 0x04, 0x06, 0x08, 0x03, 0x07, 0x07, 0x06, 0x07, 0x07, 
    0x05, 0x07, 0x07, 0x02, 0x03, 0x06, 0x02, 0x0A, 0x07, 0x07, 
    0x07, 0x07, 0x05, 0x06, 0x05, 0x07, 0x07, 0x0B, 0x06, 0x07, 
    0x05, 0x05, 0x01, 0x05, 0x07, 0x08, 
    
    // font data
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 32
    0xFE, 0xFE, 0x18, 0x18, // 33
    0x1E, 0x1E, 0x00, 0x1E, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, // 34
    0x90, 0xF8, 0x9E, 0x90, 0xF8, 0x9E, 0x1C, 0x00, 0x00, 0x1C, 0x00, 0x00, // 35
    0x18, 0x3C, 0x26, 0xFF, 0x66, 0xCC, 0x88, 0x04, 0x0C, 0x18, 0x3C, 0x18, 0x0C, 0x04, // 36
    0x1C, 0x22, 0x1C, 0xC0, 0x30, 0x8E, 0x40, 0x80, 0x00, 0x00, 0x18, 0x04, 0x00, 0x0C, 0x10, 0x0C, // 37
    0x80, 0xCC, 0x7E, 0x72, 0xF2, 0xDE, 0x0C, 0x80, 0x00, 0x0C, 0x1C, 0x10, 0x10, 0x10, 0x1C, 0x0C, 0x1C, 0x10, // 38
    0x1E, 0x1E, 0x00, 0x00, // 39
    0xF0, 0xFC, 0x06, 0x1C, 0x7C, 0xC0, // 40
    0x06, 0xFC, 0xF0, 0xC0, 0x7C, 0x1C, // 41
    0x14, 0x14, 0x0E, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, // 42
    0x60, 0x60, 0x60, 0xFC, 0xFC, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x00, // 43
    0x00, 0x00, 0x58, 0x38, // 44
    0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, // 45
    0x00, 0x00, 0x18, 0x18, // 46
    0x00, 0xC0, 0x38, 0x06, 0x18, 0x04, 0x00, 0x00, // 47
    0xF8, 0xFC, 0x0E, 0x06, 0x0E, 0xFC, 0xF8, 0x04, 0x0C, 0x1C, 0x18, 0x1C, 0x0C, 0x04, // 48
    0x18, 0x0C, 0xFE, 0xFE, 0x00, 0x00, 0x1C, 0x1C, // 49
    0x18, 0x1C, 0x86, 0xC6, 0x66, 0x3E, 0x1C, 0x18, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x18, // 50
    0x88, 0x8C, 0x06, 0x26, 0x26, 0xFE, 0xDC, 0x04, 0x0C, 0x1C, 0x18, 0x18, 0x0C, 0x04, // 51
    0xC0, 0xE0, 0xB8, 0x8C, 0xFE, 0xFE, 0x80, 0x04, 0x04, 0x04, 0x04, 0x1C, 0x1C, 0x04, // 52
    0x70, 0x7E, 0x3E, 0x36, 0x36, 0xF6, 0xC6, 0x0C, 0x1C, 0x18, 0x18, 0x18, 0x0C, 0x04, // 53
    0xF8, 0xFC, 0x6E, 0x66, 0x66, 0xEE, 0xCC, 0x04, 0x0C, 0x18, 0x18, 0x18, 0x1C, 0x0C, // 54
    0x06, 0x06, 0x06, 0xE6, 0x76, 0x1E, 0x06, 0x00, 0x00, 0x1C, 0x1C, 0x00, 0x00, 0x00, // 55
    0x9C, 0xFE, 0x66, 0x66, 0x66, 0xFE, 0x9C, 0x0C, 0x1C, 0x18, 0x18, 0x18, 0x1C, 0x0C, // 56
    0x3C, 0x7E, 0x66, 0x66, 0x66, 0xFC, 0xF8, 0x0C, 0x1C, 0x18, 0x18, 0x1C, 0x0C, 0x04, // 57
    0x18, 0x18, 0x18, 0x18, // 58
    0x18, 0x18, 0x58, 0x38, // 59
    0x60, 0x60, 0xF0, 0xF0, 0x98, 0x98, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x0C, // 60
    0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 61
    0x0C, 0x98, 0x98, 0xF0, 0xF0, 0x60, 0x60, 0x0C, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, // 62
    0x08, 0x0C, 0x06, 0xC6, 0xE6, 0x76, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, // 63
    0xE0, 0x30, 0x08, 0xC4, 0xF6, 0x3A, 0x1A, 0x1A, 0xF2, 0xFA, 0x7E, 0x04, 0x08, 0xF0, 0x0C, 0x30, 0x60, 0x4C, 0x9C, 0x98, 0x98, 0x8C, 0x9C, 0x9C, 0x90, 0x48, 0x4C, 0x20, // 64
    0x00, 0xC0, 0xF8, 0xBE, 0x86, 0xBE, 0xF8, 0xC0, 0x00, 0x18, 0x1C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1C, 0x18, // 65
    0xFE, 0xFE, 0x66, 0x66, 0x66, 0x66, 0xFE, 0xDC, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x18, 0x1C, 0x0C, // 66
    0xF8, 0xFC, 0x0E, 0x06, 0x06, 0x0E, 0x9C, 0x08, 0x04, 0x0C, 0x1C, 0x18, 0x18, 0x1C, 0x0C, 0x04, // 67
    0xFE, 0xFE, 0x06, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x1C, 0x0C, 0x04, // 68
    0xFE, 0xFE, 0x66, 0x66, 0x66, 0x66, 0x66, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x18, 0x18, // 69
    0xFE, 0xFE, 0x66, 0x66, 0x66, 0x66, 0x06, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, // 70
    0xF8, 0xFC, 0x0E, 0x06, 0x06, 0xC6, 0xCE, 0xDC, 0xC8, 0x04, 0x0C, 0x1C, 0x18, 0x18, 0x18, 0x18, 0x0C, 0x04, // 71
    0xFE, 0xFE, 0x60, 0x60, 0x60, 0x60, 0xFE, 0xFE, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x1C, // 72
    0xFE, 0xFE, 0x1C, 0x1C, // 73
    0x80, 0x80, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x0C, 0x1C, 0x18, 0x18, 0x18, 0x1C, 0x0C, // 74
    0xFE, 0xFE, 0x60, 0x30, 0x78, 0xEC, 0x86, 0x02, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x04, 0x1C, 0x18, // 75
    0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x18, 0x18, // 76
    0xFE, 0xFE, 0x0E, 0x7C, 0xE0, 0x00, 0xE0, 0x7C, 0x0E, 0xFE, 0xFE, 0x1C, 0x1C, 0x00, 0x00, 0x0C, 0x1C, 0x0C, 0x00, 0x00, 0x1C, 0x1C, // 77
    0xFE, 0xFE, 0x1C, 0x78, 0xE0, 0x80, 0xFE, 0xFE, 0x1C, 0x1C, 0x00, 0x00, 0x04, 0x0C, 0x1C, 0x1C, // 78
    0xF8, 0xFC, 0x0E, 0x06, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x04, 0x0C, 0x1C, 0x18, 0x18, 0x18, 0x1C, 0x0C, 0x04, // 79
    0xFE, 0xFE, 0x66, 0x66, 0x66, 0x7E, 0x3C, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, // 80
    0xF8, 0xFC, 0x0E, 0x06, 0x86, 0x06, 0x0E, 0xFC, 0xF8, 0x04, 0x0C, 0x1C, 0x18, 0x18, 0x1C, 0x0C, 0x1C, 0x24, // 81
    0xFE, 0xFE, 0x66, 0x66, 0xE6, 0xE6, 0xBE, 0x1C, 0x00, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x0C, 0x1C, 0x18, 0x10, // 82
    0x3C, 0x7E, 0x66, 0x66, 0x66, 0xEE, 0xCC, 0x0C, 0x1C, 0x18, 0x18, 0x18, 0x1C, 0x0C, // 83
    0x06, 0x06, 0x06, 0xFE, 0xFE, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x00, 0x00, 0x00, // 84
    0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x04, 0x0C, 0x1C, 0x18, 0x18, 0x1C, 0x0C, 0x04, // 85
    0x02, 0x1E, 0xFC, 0xE0, 0x00, 0xE0, 0xFC, 0x1E, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x00, 0x00, 0x00, // 86
    0x06, 0xFE, 0xF8, 0x00, 0xF0, 0xFE, 0x0E, 0xFE, 0xF0, 0x00, 0xF8, 0xFE, 0x06, 0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x00, 0x00, // 87
    0x06, 0x0E, 0xF8, 0xF0, 0xF8, 0x0E, 0x06, 0x18, 0x1C, 0x04, 0x00, 0x04, 0x1C, 0x18, // 88
    0x06, 0x0E, 0x38, 0xF0, 0xF0, 0x38, 0x0E, 0x06, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x00, 0x00, 0x00, // 89
    0x06, 0x06, 0x86, 0xE6, 0x76, 0x1E, 0x0E, 0x06, 0x18, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x18, 0x18, // 90
    0xFE, 0xFE, 0x06, 0x06, 0xFC, 0xFC, 0xC0, 0xC0, // 91
    0x06, 0x38, 0xC0, 0x00, 0x00, 0x00, 0x04, 0x18, // 92
    0x06, 0x06, 0xFE, 0xFE, 0xC0, 0xC0, 0xFC, 0xFC, // 93
    0x20, 0x38, 0x0E, 0x0E, 0x38, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 94
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, // 95
    0x02, 0x06, 0x04, 0x00, 0x00, 0x00, // 96
    0x10, 0x98, 0xD8, 0x58, 0xF8, 0xF0, 0x00, 0x0C, 0x1C, 0x18, 0x18, 0x0C, 0x1C, 0x10, // 97
    0xFE, 0xFE, 0x30, 0x18, 0x38, 0xF0, 0xE0, 0x1C, 0x1C, 0x0C, 0x18, 0x1C, 0x0C, 0x04, // 98
    0xE0, 0xF0, 0x18, 0x18, 0x38, 0x30, 0x04, 0x0C, 0x18, 0x18, 0x1C, 0x0C, // 99
    0xE0, 0xF0, 0x38, 0x18, 0x30, 0xFE, 0xFE, 0x04, 0x0C, 0x1C, 0x18, 0x0C, 0x1C, 0x1C, // 100
    0xE0, 0xF0, 0xD8, 0xD8, 0xD8, 0xF0, 0xE0, 0x04, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x08, // 101
    0x18, 0xFC, 0xFE, 0x1A, 0x1A, 0x00, 0x1C, 0x1C, 0x00, 0x00, // 102
    0xE0, 0xF0, 0x38, 0x18, 0x30, 0xF8, 0xF8, 0x64, 0xEC, 0xDC, 0xD8, 0xCC, 0xFC, 0x7C, // 103
    0xFE, 0xFE, 0x30, 0x18, 0x18, 0xF8, 0xF0, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x1C, 0x1C, // 104
    0xFA, 0xFA, 0x1C, 0x1C, // 105
    0x00, 0xFA, 0xFA, 0xC0, 0xFC, 0x7C, // 106
    0xFE, 0xFE, 0xE0, 0xF0, 0x98, 0x08, 0x1C, 0x1C, 0x00, 0x04, 0x1C, 0x18, // 107
    0xFE, 0xFE, 0x1C, 0x1C, // 108
    0xF8, 0xF8, 0x10, 0x18, 0xF8, 0xF0, 0x18, 0x18, 0xF8, 0xF0, 0x1C, 0x1C, 0x00, 0x00, 0x1C, 0x1C, 0x00, 0x00, 0x1C, 0x1C, // 109
    0xF8, 0xF8, 0x30, 0x18, 0x18, 0xF8, 0xF0, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x1C, 0x1C, // 110
    0xE0, 0xF0, 0x38, 0x18, 0x38, 0xF0, 0xE0, 0x04, 0x0C, 0x1C, 0x18, 0x1C, 0x0C, 0x04, // 111
    0xF8, 0xF8, 0x30, 0x18, 0x38, 0xF0, 0xE0, 0xFC, 0xFC, 0x0C, 0x18, 0x1C, 0x0C, 0x04, // 112
    0xE0, 0xF0, 0x38, 0x18, 0x30, 0xF8, 0xF8, 0x04, 0x0C, 0x1C, 0x18, 0x0C, 0xFC, 0xFC, // 113
    0xF8, 0xF8, 0x30, 0x18, 0x18, 0x1C, 0x1C, 0x00, 0x00, 0x00, // 114
    0x70, 0xF8, 0xD8, 0xD8, 0xD8, 0x90, 0x08, 0x18, 0x18, 0x18, 0x1C, 0x0C, // 115
    0x18, 0xFC, 0xFE, 0x18, 0x18, 0x00, 0x0C, 0x1C, 0x18, 0x18, // 116
    0xF8, 0xF8, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0x0C, 0x1C, 0x18, 0x18, 0x0C, 0x1C, 0x1C, // 117
    0x38, 0xF8, 0xC0, 0x00, 0xC0, 0xF8, 0x38, 0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x00, 0x00, // 118
    0x18, 0xF8, 0xE0, 0x00, 0xF0, 0x38, 0xF0, 0x00, 0xE0, 0xF8, 0x18, 0x00, 0x00, 0x1C, 0x1C, 0x0C, 0x00, 0x0C, 0x1C, 0x1C, 0x00, 0x00, // 119
    0x18, 0x38, 0xE0, 0xE0, 0x38, 0x18, 0x18, 0x1C, 0x04, 0x04, 0x1C, 0x18, // 120
    0x18, 0xF8, 0xE0, 0x00, 0xE0, 0xF8, 0x18, 0x00, 0x84, 0xFC, 0xF8, 0x3C, 0x04, 0x00, // 121
    0x18, 0x98, 0xD8, 0x78, 0x38, 0x1C, 0x1C, 0x18, 0x18, 0x18, // 122
    0x80, 0xFC, 0x7E, 0x06, 0x06, 0x00, 0x7C, 0xFC, 0xC0, 0xC0, // 123
    0xFE, 0xFC, // 124
    0x06, 0x06, 0x7E, 0xFC, 0x80, 0xC0, 0xC0, 0xFC, 0x7C, 0x00, // 125
    0x60, 0x30, 0x30, 0x70, 0x60, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 126
    0xFE, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xFE, 0x1C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1C // 127

};

/*uint8_t getCharDataStart( char* mCharSet )
{
	uint8_t characters = mCharSet[5];
	return *(mCharSet+6+characters);
}

uint8_t getCharWidth( char* mCharSet, uint8_t mIndex )
{
	return  mCharSet[5+mIndex];
}

uint8_t charToIndex( char* mCharSet, char mCharacter)
{
	return (mCharacter - Arial_bold_14[4]);
}*/

// 2X this number gives the offset to the start
// of the character's data.
/*uint8_t sumOfWidths( char* mCharSet, char mCharacter)
{
	uint8_t index = charToIndex( mCharacter);
	uint8_t sum = 0;
	for (int i=5; i<index; i++)
		sum += mCharSet[i]
	return sum;
}

void DrawText( char* mText )
{
	uint8_t char_data = getCharDataStart( Arial_bold_14 );
	TransferBufferFixedLength( _far const char * mData, uint8_t length );
}*/

#define GotoXY 		GotoAddress
#define WriteData	LCD_write_data

/**
 * output a character
 *
 * @param c the character to output
 *
 * If the character will not fit on the current text line
 * inside the text area,
 * the text position is wrapped to the next line. This might be
 * the next lower or the next higher line depending on the
 * scroll direction.
 *
 * If there is not enough room to fit a full line of new text after
 * wrapping, the entire text area will be scrolled to make room for a new
 * line of text. The scroll direction will be up or down
 * depending on the scroll direction for the text area.
 * 
 * @see Puts()
 * @see Puts_P()
 * @see write()
 */
struct tarea starea;

Font_t 	Font;
uint8_t	FontColor;
uint8_t FontRead(const uint8_t* value) { return *value;  }

void selectFont( Font_t mFont )
{
	Font = mFont;
}

int PutChar(uint8_t c)
{
uint8_t			x;
uint8_t			y;

    if(Font == 0)
	  return 0; // no font selected

	/*
	 * check for special character processing
	 */

	if(c < 0x20)
	{
		//SpecialChar(c);
		return 1;
	}
	   
	uint8_t width = 0;
	uint8_t height = FontRead(Font+FONT_HEIGHT);
	uint8_t bytes = (height+7)/8; /* calculates height in rounded up bytes */
	
	uint8_t firstChar = FontRead(Font+FONT_FIRST_CHAR);
	uint8_t charCount = FontRead(Font+FONT_CHAR_COUNT);
	
	uint16_t index = 0;
	uint8_t thielefont;

	if(c < firstChar || c >= (firstChar+charCount)) {
		return 0; // invalid char
	}
	c-= firstChar;

	if( isFixedWidthFont(Font) {
		thielefont = 0;
		width = FontRead(Font+FONT_FIXED_WIDTH); 
		index = c*bytes*width+FONT_WIDTH_TABLE;
	}
	else{
	// variable width font, read width data, to get the index
		thielefont = 1;
		/*
		 * Because there is no table for the offset of where the data
		 * for each character glyph starts, run the table and add up all the
		 * widths of all the characters prior to the character we
		 * need to locate.
		 */
	   for(uint8_t i=0; i<c; i++) {  
		 index += FontRead(Font+FONT_WIDTH_TABLE+i);
	   }
		/*
		 * Calculate the offset of where the font data
		 * for our character starts.
		 * The index value from above has to be adjusted because
		 * there is potentialy more than 1 byte per column in the glyph,
		 * when the characgter is taller than 8 bits.
		 * To account for this, index has to be multiplied
		 * by the height in bytes because there is one byte of font
		 * data for each vertical 8 pixels.
		 * The index is then adjusted to skip over the font width data
		 * and the font header information.
		 */

	   index = index*bytes+charCount+FONT_WIDTH_TABLE;

		/*
		 * Finally, fetch the width of our character
		 */
	   width = FontRead(Font+FONT_WIDTH_TABLE+c);
    }

#ifndef GLCD_NODEFER_SCROLL
	/*
	 * check for a defered scroll
	 * If there is a deferred scroll,
	 * Fake a newline to complete it.
	 */

	if(need_scroll)
	{
		PutChar('\n'); // fake a newline to cause wrap/scroll
		need_scroll = 0;
	}
#endif

	/*
	 * If the character won't fit in the text area,
	 * fake a newline to get the text area to wrap and 
	 * scroll if necessary.
	 * NOTE/WARNING: the below calculation assumes a 1 pixel pad.
	 * This will need to be changed if/when configurable pixel padding is supported.
	 */
	/*if(x + width > starea.x2)
	{
		PutChar('\n'); // fake a newline to cause wrap/scroll
#ifndef GLCD_NODEFER_SCROLL
		*
		 * We can't defer a scroll at this point since we need to ouput
		 * a character right now.
		 *
		if(need_scroll)
		{
			PutChar('\n'); // fake a newline to cause wrap/scroll
			need_scroll = 0;
		}
#endif
	} */

	// last but not least, draw the character

#ifdef GLCD_OLD_FONTDRAW
/*================== OLD FONT DRAWING ============================*/
	GotoXY(x, y);
	for(uint8_t i=0; i<bytes; i++)	/* each vertical byte */
	{
		uint16_t page = i*width; // page must be 16 bit to prevent overflow
		for(uint8_t j=0; j<width; j++) /* each column */
		{
			uint8_t data = FontRead(Font+index+page+j);

			if(height > 8 && height < (i+1)*8)	/* is it last byte of multibyte tall font? */
			{
				data >>= (i+1)*8-height;
			}
			
			if(FontColor == BLACK) {
				WriteData(data);
			} else {
				WriteData(~data);
			}
		}
		// 1px gap between chars
		if(FontColor == BLACK) {
			WriteData(0x00);
		} else {
			WriteData(0xFF);
		}
		//y_address  Coord.y
		GotoXY(x, y+8);
	}
	x = x+width+1;
#else
/*================== NEW FONT DRAWING ===================================*/
	/*
	 * Paint font data bits and write them to LCD memory 1 LCD page at a time.
	 * This is very different from simply reading 1 byte of font data
	 * and writing all 8 bits to LCD memory and expecting the write data routine
	 * to fragement the 8 bits across LCD 2 memory pages when necessary.
	 * That method (really doesn't work) and reads and writes the same LCD page 
	 * more than once as well as not do sequential writes to memory.
	 *
	 * This method of rendering while much more complicated, somewhat scrambles the font 
	 * data reads to ensure that all writes to LCD pages are always sequential and a given LCD
	 * memory page is never read or written more than once.
	 * And reads of LCD pages are only done at the top or bottom of the font data rendering
	 * when necessary. 
	 * i.e it ensures the absolute minimum number of LCD page accesses
	 * as well as does the sequential writes as much as possible.
	 *
	 */
	uint8_t pixels = height +1; /* 1 for gap below character*/
	uint8_t p;
	uint8_t dy;
	uint8_t tfp;
	uint8_t dp;
	uint8_t dbyte;
	uint8_t fdata;

	for(p = 0; p < pixels;)
	{
		dy = y + p;

		/*
		 * Align to proper Column and page in LCD memory
		 */

		GotoXY(x, (dy & ~7));

		uint16_t page = p/8 * width; // page must be 16 bit to prevent overflow

		for(uint8_t j=0; j<width; j++) /* each column of font data */
		{
			if(p >= height)
			{
				fdata = 0;
			}
			else
			{
				fdata = FontRead(Font+index+page+j);
				if(thielefont && (height - (p&~7)) < 8)
				{
					fdata >>= 8 - (height & 7);
				}
			}

			if(FontColor == WHITE)
				fdata ^= 0xff;	/* inverted data for "white" font color	*/

			if(!(dy & 7) && !(p & 7) && ((pixels -p) >= 8))
			{
					WriteData(fdata);
					continue;
			}
			else
			{
					dbyte = glcd_Device::ReadData();
			}
			tfp = p;		/* font pixel bit position 		*/
			dp = dy & 7;	/* data byte pixel bit position */

			while((dp <= 7) && (tfp) < pixels)
			{
				if(fdata & _BV(tfp & 7))
				{
					dbyte |= _BV(dp);
				}
				else
				{
					dbyte &= ~_BV(dp);
				}

				if((tfp & 7)== 7)
				{
					fdata = FontRead(Font+index+page+j+width);
					if((thielefont) && ((height - tfp) < 8))
					{
						fdata >>= (8 - (height & 7));
					}
					if(FontColor == WHITE)
						fdata ^= 0xff;	/* inverted data for "white" color	*/
				}
				tfp++;
				dp++;
			}
			WriteData(dbyte);
		}		
		if((dy & 7) || (pixels - p < 8))
		{
		uint8_t mask = 0;
			dbyte = glcd_Device::ReadData();

			if(dy & 7)
				mask |= _BV(dy & 7) -1;
			if((pixels-p) < 8)
				mask |= ~(_BV(pixels - p) -1);
			if(FontColor == WHITE)
				dbyte |= ~mask;	
			else
				dbyte &= mask;
		}
		else
		{
			if(FontColor == WHITE)
				dbyte = 0xff;
			else
				dbyte = 0;
		}

		WriteData(dbyte);
		p += 8 - (dy & 7);
	}
	x = x+width+1;
/*================== END of NEW FONT DRAWING ============================*/
#endif // NEW_FONTDRAW
	return 1; // valid char
}

int aText_Out( char* mString )
{
	int i;	
	int length = strlen(mString);
	for (i=0; i<length; i++)
	{
		PutChar( (uint8_t)mString[i] );
	}
	return i;	// number chars drawn
}

